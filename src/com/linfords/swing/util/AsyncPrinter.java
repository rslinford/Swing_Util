package com.linfords.swing.util;

import java.io.PrintStream;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.io.Writer;
import java.lang.management.ThreadInfo;
import java.util.concurrent.PriorityBlockingQueue;

public class AsyncPrinter extends Thread {

	private final static String THREAD_NAME_PREFIX = "AsyncPrinter ";

	public static abstract class Expression implements Comparable<Expression> {
		private static int nextPriority = Integer.MIN_VALUE;
		private final int priority;

		abstract public Object eval();

		public Expression() {
			priority = nextPriority++;
		}

		@Override
		public int compareTo(Expression other) {
			return this.priority - other.priority;
		}
	}

	public static enum Action {
		QUEUE, STASH
	}

	private boolean notDone = true;
	private final PriorityBlockingQueue<Expression> queue = new PriorityBlockingQueue<Expression>();
	private final PriorityBlockingQueue<Expression> deferredQueue = new PriorityBlockingQueue<Expression>();
	private final PrintStream out;

	private static AsyncPrinter DEFAULT_INSTANCE = null;

	/**
	 * Return the default instance. Lazy creates. Starts the thread
	 * automatically.
	 */
	synchronized public static AsyncPrinter defaultInstance() {
		if (DEFAULT_INSTANCE == null) {
			DEFAULT_INSTANCE = new AsyncPrinter(System.out, "Default");
			DEFAULT_INSTANCE.start();
		}
		return DEFAULT_INSTANCE;
	}

	public AsyncPrinter(final PrintStream out, final String threadNamePostfix) {
		super(THREAD_NAME_PREFIX + threadNamePostfix);
		this.out = out;
	}

	public AsyncPrinter(final PrintStream out, final Class<?> threadNameTag) {
		this(out, threadNameTag.getName());
	}

	public void requestStop() {
		notDone = true;
		// Allow method 'run()' to complete gracefully if it is blocking on
		// 'queue.take()'
		add("");
	}

	public void run() {
		// Try block is to catch unhandled exceptions generated by calls to method 'eval()'.
		// Also, method 'take' may throw InterruptedException for some unspecified reason.
		while (notDone) {
			try {
				// Method 'take' blocks if the 'queue' is empty.
				out.println(queue.take().eval());
			} catch (Exception e) {
				System.err.println("Unhandled error. Thread '"
						+ super.getName() + "' will continue. Exception:");
				e.printStackTrace();
			}
		}
	}

	public int deferredItemSize() {
		return deferredQueue.size();
	}

	public void dropDeferredItems() {
		deferredQueue.clear();
	}

	public void printDeferredItems() {
		deferredQueue.drainTo(queue);
	}

	public void add(final Expression output) {
		add(output, Action.QUEUE);
	}

	public void add(final Expression output, final Action action) {
		if (output == null) {
			return;
		}

		if (action == Action.STASH) {
			deferredQueue.add(output);
		} else {
			queue.add(output);
		}
	}

	public void add(final StringBuffer sb) {
		add(sb, Action.QUEUE);
	}

	public void add(final StringBuffer sb, final Action action) {
		if (sb == null) {
			return;
		}

		add(new Expression() {
			@Override
			public Object eval() {
				return sb;
			}
		}, action);
	}

	public void add(final String string) {
		add(string, Action.QUEUE);
	}

	public void add(final String string, final Action action) {
		if (string == null) {
			return;
		}

		add(new Expression() {
			@Override
			public Object eval() {
				return string;
			}
		}, action);
	}

	public void add(final Throwable t) {
		add(t, Action.QUEUE);
	}

	public void add(final Throwable t, final Action action) {
		if (t == null) {
			return;
		}

		add(new Expression() {
			@Override
			public Object eval() {
				final Writer result = new StringWriter();
				final PrintWriter printWriter = new PrintWriter(result);
				t.printStackTrace(printWriter);
				return result.toString();
			}
		}, action);
	}

	public void add(final Object object) {
		add(object, Action.QUEUE);
	}

	public void add(final Object object, final Action action) {
		if (object == null) {
			return;
		}

		add(new Expression() {
			@Override
			public Object eval() {
				return object;
			}
		}, action);
	}

	public void add(final ThreadInfo ti) {
		add(ti, Action.QUEUE);
	}

	/**
	 * Returns a string representation of ThreadInfo ti. Copied from the
	 * ThreadInfo.toString() Java source, but with the retarded, hard-coded,
	 * limit of 8 removed for the stack trace output.
	 * 
	 * the {@linkplain #getThreadName thread name}, the
	 * {@linkplain #getThreadId thread ID}, its {@linkplain #getThreadState
	 * state}, and a {@linkplain #getStackTrace stack trace} if any.
	 */
	public void add(final ThreadInfo ti, final Action action) {
		if (ti == null) {
			return;
		}

		add(new Expression() {
			@Override
			public Object eval() {
				return Util.fullStackTrace(ti);
			}
		}, action);
	}

	/**
	 * Factory method that creates a {@code Divider}, an inner class, so that it
	 * is associated with {@code this} AsyncPrinter.
	 * <p>
	 * Factory methods are provided for {@code Divider} objects to avoid the
	 * weird 'enclosing instance' syntax.
	 * 
	 * @see com.linfords.swing.util.AsyncPrinter#createDivider(com.linfords.swing.util.AsyncPrinter.Divider header)
	 * @param tag
	 * @param style
	 * @return
	 */
	public Divider createDivider(String tag, DividerStyle style) {
		return new Divider(tag, style);
	}

	/**
	 * Creates a {@code Divider} with style {@code DividerStyle.END} and with
	 * the same tag as the provided {@code Divider} {@code header}.
	 * <p>
	 * Factory method that creates a new Divider, an inner class, so that it is
	 * associated with 'this' AsyncPrinter. Factory methods are provided for
	 * Divider objects to avoid the weird 'enclosing instance' syntax.
	 * 
	 * @see com.linfords.swing.util.AsyncPrinter#createDivider(String, com.linfords.swing.util.AsyncPrinter.DividerStyle)
	 * @param header
	 * @return
	 */
	public Divider createDivider(Divider header) {
		return new Divider(header);
	}

	public static enum DividerStyle {
		BEGIN, END, NEUTRAL
	}

	public class Divider {

		final static String BEGIN_DIVIDERS = "vvvvvvvvvvvvvvvvvvvvvvvv";
		final static String END_DIVIDERS = "^^^^^^^^^^^^^^^^^^^^^^^^";
		final static String NEUTRAL_DIVIDERS = "************************";

		private boolean hasBeenPrinted = false;
		final private String tag;
		final private DividerStyle style;

		private Divider(String tag, DividerStyle style) {
			this.tag = tag;
			this.style = style;
		}

		private Divider(Divider header) {
			this.tag = header.tag;
			this.style = DividerStyle.END;
		}

		Expression exp = new Expression() {
			@Override
			public Object eval() {
				StringBuffer sb = new StringBuffer();
				if ((style == DividerStyle.BEGIN)
						|| (style == DividerStyle.NEUTRAL)) {
					sb.append('\n');
				}

				if (style == DividerStyle.BEGIN) {
					sb.append(BEGIN_DIVIDERS).append(tag)
							.append(BEGIN_DIVIDERS);
				} else if (style == DividerStyle.END) {
					sb.append(END_DIVIDERS).append(tag).append(END_DIVIDERS);
				} else {
					sb.append(NEUTRAL_DIVIDERS).append(tag)
							.append(NEUTRAL_DIVIDERS);
				}

				if ((style == DividerStyle.END)
						|| (style == DividerStyle.NEUTRAL)) {
					sb.append('\n');
				}

				return sb.toString();
			}
		};

		/**
		 * Prints this divider on the first call with subsequent calls silently
		 * ignored
		 */
		public void printFirstTimeOnly() {
			synchronized (this) {
				if (hasBeenPrinted) {
					return;
				}
				hasBeenPrinted = true;
			}
			add(exp);
		}

		public boolean hasBeenPrinted() {
			return hasBeenPrinted;
		}
	}
}
